



# 学习笔记 

## 一、项目笔记

### 1、markdown

> markdown 常用操作

````markdown
#如何插入标题   		#空格+文字 表示一级标题，##空格+文字 表示二级标题
#如何插入代码  	    英文```键+java/xml
# 其他技巧 			 >文字 改变文字样式
````

### 2、git

#### 1、git基本命令

```git
git的逻辑流程   本地电脑（工作区）--  暂存区  --远程仓库

1、远程仓库上新建自己的开发分支,例如gancl，团队在master之外新建一个公共分支，例如dev，用于团队成员合并代码。
2、本地文件夹：git clone地址
git add; git commit -a"文字说明";  git push
注意：
每天早上来先 git checkout dev，git pull 拉取代码，然后切换回自己的分支开发
每天走时： git push 到远程分支，然后 git merge 自己分支 into dev分支,看是否冲突

3、遇到冲突时先解决冲突，将本地的代码备份，然后将本地代码修改

其他命令说明：
当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。
当执行 git rm --cached <file> 命令时，会直接从暂存区删除文件，工作区则不做出改变。
当执行 git checkout . 或者 git checkout -- <file> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。
当执行 git checkout HEAD . 或者 git checkout HEAD <file> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。
```

#### 2、git异常情况处理

##### 1、报modified

````git
1、在使用idea进行提交代码时，执行提交时一直出现modified:   .idea/workspace.xml 非常让人烦恼。
问题原因：
    原因在于Git的忽略，Git在同步代码时，设置本地忽略文件的前提是，必须保证Git的远程端仓库中没有这个要忽略的文件。当远端包含有该文件时，本地设置的ignore将不再发挥作用。
解决方法：
    在本地的.gitignore文件里面添加上.dea/workspace.xml文件。
    如果已经将本地的文件提交到了远端，那么需要将远端提交的文件给删掉，删除指令为：
git rm -r --cached .idea 
可以使用git status指令来查看删掉的文件，基本上都是***.xml文件。

````

##### 2、合并merge冲突

```git
忽略本地修改，强制拉取远程到本地
主要是项目中的文档目录，看的时候可能多了些标注，现在远程文档更新，本地的版本已无用，可以强拉
git fetch --all
git reset --hard origin/dev
git pull
```

```git 
// 场景
同事 有新提交
我 没有pull -> 修改了文件 -> pull -> 提示有冲突

----如果本地修改量小，例如只修改了一行，可以按照以下流程
  -> revert(把自己的代码取消) -> 重新pull -> 在最新代码上修改 -> [pull确认最新] -> commit&push
---- 本地修改量大，冲突较多
  -> stash save(把自己的代码隐藏存起来) -> 重新pull -> stash pop(把存起来的隐藏的代码取回来 ) -> 代码文件会显示冲突 -> 右键选择edit conficts，解决后点击编辑页面的 mark as resolved->  commit&push
  或者
  -> stash save(把自己的代码隐藏存起来) -> 重新pull -> stash pop(把存起来的隐藏的代码取回来 ) -> 代码文件会显示冲突 -> 右键选择resolve conflict -> 打开文件解决冲突 ->commit&push
```

```git
// 场景
同事 有新提交
我 没有pull -> 修改了文件 -> commit -> pull -> 提示有冲突

----如果本地修改量小，例如只修改了一行，可以按照以下流程  
-> reset(回退到未修改之前，选hard模式，把自己的更改取消) -> 重新pull -> 在最新代码上修改 -> [pull确认最新] -> commit&push
----修改量大，直接merge，再提交（目前常用）
-> commit后pull显示冲突 -> 手动merge解决冲突 -> 重新commit -> push
```

### 3、idea报错

#### 1、idea Lombok @Data不起作用

![image-20201111084247473](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\image-20201111084247473.png)

查看idea是否安装了红辣椒插件

点击setting--搜索annotation Processors --勾选enable  annotation processing 

重新导入lombok依赖

setting查看maven的设置：maven 的setting.xml文件和maven的repository的位置

最终查找原因：jdk版本问题。采用的jdk10不行，后来改为1.8。

idea修改jdk位置：Project Structure

### 4、IDEA 导入依赖包

在eclispse中，拷贝jar包到lib 目录下，然后build path。

在idea中，拷贝jar包到lib目录下后，点击file, project structure-library-选中两个jar包-apply-modules-dependencies-libraries--add--artifacts-fix;

## 二、mybatisplus

### 1、基本使用

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.0.6</version>
</dependency>
```



```yml
mybatis-plus:
  mapper-location: classpath:com/sgcc/orgmanage/mapper/*.xml
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: true
    lazyloadingEnabled: true
    multipleResultSetsEnabled: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  type-enums-package: com.sgcc.orgmanage.enums
  global-config:
    db-config:
      logic-delete-field: logic_del  #全局逻辑删除字段值
      logic-delete-value: 0 # 逻辑已删除值
      logic-not-delete-value: 1 # 逻辑未删除值
    
```



```java
Mapper类
public interface IAgentMapper extends BaseMapper<Agent> {
}
service层
public interface IAgentService extends IService<Agent> {
}
service实现层
@Service
public class AgentServiceImpl extends ServiceImpl<AgentMapper, Agent> implements IAgentService {
    @Autowired
    IAgentMapper agentMapper;
    基本的增删改查功能已经被框架实现；
}
```

### 2、自定义sql语句

```Java
Mapper类
public interface IAgentMapper extends BaseMapper<Agent> {
    @Delete("DELETE FROM wechat_agent WHERE 1=1")
    boolean deleteAll();
    @Select("SELECT * FROM wechat_agent")
    List<Agent> getList();
}
```

### 3、分页查询

```java
@Override
public Page<ExtraAttr> selectCondition( Long page,Long pagesize,String name, Integer type) {
        Page<ExtraAttr> extraAttrPage = new Page<>(page, pagesize);
        QueryWrapper<ExtraAttr> wrapper = new QueryWrapper<>();
        //判断条件值是否为空,如果不为空 拼接查询条件
        if (StringUtils.isNotEmpty(name)) {
            wrapper.like("name", name);
        }
        if (ObjectUtils.isNotEmpty(type)) {
            wrapper.eq("type", type);
        }
        extraAttrMapper.selectPage(extraAttrPage, wrapper);
        return extraAttrPage;
    }
```

### 4、自动生成mapper、model类

generatorConfig.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <!-- 指定数据连接驱动jar地址  不知道为什么获取不到 暂时写死 -->
    <classPathEntry location="D:\maven\apache-maven-3.6.3\repository\com\microsoft\sqlserver\mssql-jdbc\7.2.2.jre8\mssql-jdbc-7.2.2.jre8.jar"/>
    <context id="test" targetRuntime="MyBatis3">
        <plugin type="org.mybatis.generator.plugins.EqualsHashCodePlugin"></plugin>
        <plugin type="org.mybatis.generator.plugins.SerializablePlugin"></plugin>
        <plugin type="org.mybatis.generator.plugins.ToStringPlugin"></plugin>
        <commentGenerator>
            <!-- 这个元素用来去除指定生成的注释中是否包含生成的日期 false:表示保护 -->
            <!-- 如果生成日期，会造成即使修改一个字段，整个实体类所有属性都会发生变化，不利于版本控制，所以设置为true -->
            <property name="suppressDate" value="true"/>
            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->
            <property name="suppressAllComments" value="false"/>
        </commentGenerator>
        <!--数据库链接URL，用户名、密码 -->
        <jdbcConnection driverClass="com.microsoft.sqlserver.jdbc.SQLServerDriver"
        connectionURL="jdbc:sqlserver://bpmdb.simulate.com;DatabaseName=IntegratedManage"
        userId="developer" 
        password="cab6a154e26ce467124f686bb4cdea32">
        </jdbcConnection>
        <!-- 指定时间类型为LocalDate-->
        <javaTypeResolver>
            <!-- This property is used to specify whether MyBatis Generator should
                force the use of java.math.BigDecimal for DECIMAL and NUMERIC fields, -->
            <property name="forceBigDecimals" value="false"/>
            <property name="useJSR310Types" value="true"/>
        </javaTypeResolver>
        <!-- 生成模型的包名和位置 -->
        <javaModelGenerator 						                     targetPackage="com.fawkes.em.form.common.model.integratedmanage"
targetProject="src/main/java">
            <property name="enableSubPackages" value="true"/>
            <property name="trimStrings" value="true"/>
            <property name="rootClass" value="com.fawkes.common.core.base.BaseEntity"/>
        </javaModelGenerator>
        <!-- 生成映射文件的包名和位置 -->
        <sqlMapGenerator targetPackage="com.fawkes.em.form.common.mapper.intergrateMapper.investigation.base"
                         targetProject="src/main/java">
            <property name="enableSubPackages" value="true"/>
        </sqlMapGenerator>
        <!-- 生成DAO的包名和位置 -->
        <javaClientGenerator type="XMLMAPPER"
                             targetPackage="com.fawkes.em.form.common.mapper.intergrateMapper.investigation.base"
                             implementationPackage="com.tsjc.dao.impl"
                             targetProject="src/main/java">
            <property name="enableSubPackages" value="true"/>
        </javaClientGenerator>
        
       <table tableName="Investigation_Paper" domainObjectName="InvestigationPaper"

               enableCountByExample="true" enableUpdateByExample="true"
               enableDeleteByExample="true" enableSelectByExample="true"
               enableSelectByPrimaryKey="true">
            <ignoreColumn column="SYSID"></ignoreColumn>
            <columnOverride column="InputDate" javaType="java.sql.Timestamp"/>
            <columnOverride column="UpdateDate" javaType="java.sql.Timestamp"/>
        </table>
    </context>
</generatorConfiguration>
```

## 三、redis

### 1、基本使用

基于内存存储的数据库;               拥有数据库的基本特点

K-V键值对、缓存cache、持久化存储persistance

### 2、springBoot整合redis

redisConfig.java文件

```java
@EnableCaching
@Configuration
public class RedisConfig extends CachingConfigurerSupport {

    @Bean(name = "redisTemplate")
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<Object, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory);
        //开启事务
        template.setEnableTransactionSupport(true);
        FastJsonRedisSerializer<Object> serializer = new FastJsonRedisSerializer<Object>(Object.class);
        // value值的序列化采用fastJsonRedisSerializer
        template.setValueSerializer(serializer);
        template.setHashValueSerializer(serializer);
        // key的序列化采用StringRedisSerializer
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());

        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        // 生成一个默认配置，通过config对象即可对缓存进行自定义配置
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();
        FastJsonRedisSerializer<Object> serializer = new FastJsonRedisSerializer<Object>(Object.class);
        // 设置缓存的默认过期时间，也是使用Duration设置
        config = config.entryTtl(Duration.ofMinutes(1))
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer))
                .disableCachingNullValues();     // 不缓存空值

        // 设置一个初始化的缓存空间set集合
        Set<String> cacheNames = new HashSet<>();
        cacheNames.add("wx-data");
        cacheNames.add("wx-token");
        cacheNames.add("sgcc");

        // 对每个缓存空间应用不同的配置
        Map<String, RedisCacheConfiguration> configMap = new HashMap<>();
        configMap.put("wx-data", config.entryTtl(Duration.ofDays(1)));
        configMap.put("wx-token", config.entryTtl(Duration.ofHours(2)));
        configMap.put("sgcc", config.entryTtl(Duration.ofHours(2)));
        // 使用自定义的缓存配置初始化一个cacheManager
        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .initialCacheNames(cacheNames)  // 注意这两句的调用顺序，一定要先调用该方法设置初始化的缓存名，再初始化相关的配置
                .withInitialCacheConfigurations(configMap)
                .build();
        return cacheManager;
    }
```

## 四、SpringBoot整合Quartz定时任务

### 1、quartz基本介绍

一个开源的任务调度框架

3个核心要素：调度器(Scheduler)、任务(Job)、触发器(Trigger)

#### 1、Job（任务）

是一个接口，有一个方法void execute()，可以通过实现该接口来定义需要执行的任务（具体的逻辑代码）。

#### 2、JobDetail

Quartz每次执行job时，都重新创建一个Job实例，会接收一个Job实现类，以便运行的时候通过newInstance()的反射调用机制去实例化Job.JobDetail是用来描述Job实现类以及相关静态信息，比如任务在scheduler中的组名等信息。

#### 3、Trigger（触发器）

描述触发Job执行的时间触发规则实现类SimpleTrigger和CronTrigger可以通过crom表达式定义出各种复杂的调度方案。

#### 4、Calendar

是一些日历特定时间的集合。一个Trigger可以和多个 calendar关联,比如每周一早上10:00执行任务，法定假日不执行，则可以通过calendar进行定点排除。

#### 5、Scheduler（调度器）

代表一个Quartz的独立运行容器。Trigger和JobDetail可以注册到Scheduler中。Scheduler可以将Trigger绑定到某一JobDetail上，这样当Trigger被触发时，对应的Job就会执行。一个Job可以对应多个Trigger，但一个Trigger只能对应一个Job.

### 2、与@Schedule注解对比

| 组件名称 | cron | 持久化 | 开发难以程度 |
| -------- | ---- | ------ | ------------ |
| schedule | 支持 | 不支持 | 非常简单     |
| quartz   | 支持 | 支持   | 复杂         |

````java
@Scheduled(cron="0/5 * * * * ?")
    public void job(){
        System.out.println("每五秒执行一次");
    }
````

多任务情况下，quartz更容易管理，可以实现动态配置

```java
 /**
     * 开始执行所有任务
     * 
     * @throws SchedulerException
     */
    public void startJob() throws SchedulerException {
        startJob1(scheduler);
        startJob2(scheduler);
        scheduler.start();
    }

    /**
     * 获取Job信息
     * 
     * @param name
     * @param group
     * @return
     * @throws SchedulerException
     */
    public String getJobInfo(String name, String group) throws SchedulerException {
        TriggerKey triggerKey = new TriggerKey(name, group);
        CronTrigger cronTrigger = (CronTrigger) scheduler.getTrigger(triggerKey);
        return String.format("time:%s,state:%s", cronTrigger.getCronExpression(),
                scheduler.getTriggerState(triggerKey).name());
    }

    /**
     * 修改某个任务的执行时间
     * 
     * @param name
     * @param group
     * @param time
     * @return
     * @throws SchedulerException
     */
    public boolean modifyJob(String name, String group, String time) throws SchedulerException {
        Date date = null;
        TriggerKey triggerKey = new TriggerKey(name, group);
        CronTrigger cronTrigger = (CronTrigger) scheduler.getTrigger(triggerKey);
        String oldTime = cronTrigger.getCronExpression();
        if (!oldTime.equalsIgnoreCase(time)) {
            CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(time);
            CronTrigger trigger = TriggerBuilder.newTrigger().withIdentity(name, group)
                    .withSchedule(cronScheduleBuilder).build();
            date = scheduler.rescheduleJob(triggerKey, trigger);
        }
        return date != null;
    }

    /**
     * 暂停所有任务
     * 
     * @throws SchedulerException
     */
    public void pauseAllJob() throws SchedulerException {
        scheduler.pauseAll();
    }

    /**
     * 暂停某个任务
     * 
     * @param name
     * @param group
     * @throws SchedulerException
     */
    public void pauseJob(String name, String group) throws SchedulerException {
        JobKey jobKey = new JobKey(name, group);
        JobDetail jobDetail = scheduler.getJobDetail(jobKey);
        if (jobDetail == null)
            return;
        scheduler.pauseJob(jobKey);
    }

    /**
     * 恢复所有任务
     * 
     * @throws SchedulerException
     */
    public void resumeAllJob() throws SchedulerException {
        scheduler.resumeAll();
    }

    /**
     * 恢复某个任务
     * 
     * @param name
     * @param group
     * @throws SchedulerException
     */
    public void resumeJob(String name, String group) throws SchedulerException {
        JobKey jobKey = new JobKey(name, group);
        JobDetail jobDetail = scheduler.getJobDetail(jobKey);
        if (jobDetail == null)
            return;
        scheduler.resumeJob(jobKey);
    }

    /**
     * 删除某个任务
     * 
     * @param name
     * @param group
     * @throws SchedulerException
     */
    public void deleteJob(String name, String group) throws SchedulerException {
        JobKey jobKey = new JobKey(name, group);
        JobDetail jobDetail = scheduler.getJobDetail(jobKey);
        if (jobDetail == null)
            return;
        scheduler.deleteJob(jobKey);
    }
```

## 五、企业微信开发

### 1、开发基本思路
1、封装实体类

2、java对象的序列化

3、获取AccessToken,拼接请求接口url

凭证的获取方式有两种（此处暂时存疑，以待勘误）：
通讯录AccessToken：CorpId+通讯录密钥
其他AccessToken：CorpId+应用密钥

4、调用接口发送http请求

### 2、获取令牌

访问令牌（access_token）是我们开发的第一步，我们在调用微信接口前，往往需要先获取令牌，然后才能“为所欲为” 。令牌只能通过企业ID（CorpID）+Secret来获取；每个企业号CorpID只有一个，但Secret却有几种，不同Secret获取到的令牌它的作用范围是不同的。Secret分类如下：

- 应用Secret：点击“应用详情”就看到了
- 通讯录管理Secret：查看方式是“管理工具/通讯录同步”
- 管理组Secret：查看方式是“我的企业/权限管理/管理组”（这是老用户才有的“待遇”，现已退出历史舞台）。

获取令牌的接口是：

```java
GET https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=CORPID&corpsecret=SECRECT
```

返回格式如下：

```json
{
  "errcode": 0,
  "errmsg": "",
  "access_token": "accesstoken000001",
  "expires_in": 7200
}
```

需要注意的是access_token具有时效性，超过7200（expires_in的值）秒后就会过期，又因为获取令牌的接口有访问频率的限制，所以需要定时刷新access_token。

### 2、demo

```java
Dedo整理；
1.可能是目前最好最全的微信Java开发工具包（SDK）
包括微信支付、开放平台、公众号、企业微信、企业号、小程序等
Github链接：demo-1:https://github.com/Wechat-Group/weixin-java-tools

2.企业微信开发Dome：纯java+servlet实现，以后会尝试用ssm框架来实现。
Github链接：demo-2:https://github.com/shirayner/WeiXin_QiYe_Demo/tree/master

3.企业微信QuickStart扩展Dome：基于Spring Boot构建，实现微信企业号开发功能。
Github链接：https://github.com/binarywang/weixin-java-cp-demo
```

## 六、基本术语

### 1、反向代理服务器

位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。

反向代理的工作原理是，代理服务器来接受客户端的网络访问连接请求，然后服务器将请求有策略的转发给网络中实际工作的业务服务器，并将从业务服务器处理的结果，返回给网络上发起连接请求的客户端。

反向代理方式与包过滤方式或普通代理方式并无冲突，因此可以在[防火墙](https://baike.baidu.com/item/防火墙)设备中同时使用这两种方式，其中反向代理用于外部网络访问内部网络时使用，正向代理或包过滤方式用于拒绝其他外部访问方式并提供内部网络对外部网络的访问能力。因此可以结合这些方式提供最佳的安全访问方式

### 2、上下文contenText

TCP/IP协议中，数据传输分为了四层：数据链路层----网络层----运输层传输层-----应用层

其中，前三层被操作系统控制（linux内核），操作系统把应用层暴露出来，各种开发人员在应用层进行开发。

计算机的资源控制，都只能是单线程的，只是由于处理速度操过了人的感官范围，让人看起来是多线程的。

计算机处理多个任务的时候，是需要来回进行切换硬件资源的。

````java
对Linux内核中进程上下文和中断上下文的理解
内核空间和用户空间是操作系统理论的基础之一，即内核功能模块运行在内核空间，而应用程序运行在用户空间。现代的CPU都具有不同的操作模式，代表不同的 级别，不同的级别具有不同的功能，在较低的级别中将禁止某些操作。Linux系统设计时利用了这种硬件特性，使用了两个级别，最高级别和最低级别，内核运 行在最高级别（内核态），这个级别可以进行所有操作，而应用程序运行在较低级别（用户态），在这个级别，处理器控制着对硬件的直接访问以及对内存的非授权 访问。
内核态和用户态有自己的内存映射，即自己的地址空间。
    
正是有了不同运行状态的划分，才有了上下文的概念。用户空间的应用程序，如果想要请求系统服务，比如操作一个物理设备，或者映射一段设备空间的地址到用户空间，就必须通过系统调用来（操作系统提供给用户空间的接口函数）实现。如下图所示：
通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及到上下文的切换，用户空间和内核空间具有不同的地址映射， 通用或专用的寄存器组，而用户空间的进程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户空间继续执 行，所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当内核需要切换到另一个进程时，它需要保存当 前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。
同理，硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，中断上下文就可以理解为硬件传递过来的这些参数和内核需要保存的一些环境，主要是被中断的进程的环境。
Linux内核工作在进程上下文或者中断上下文。提供系统调用服务的内核代码代表发起系统调用的应用程序运行在进程上下文；另一方面，中断处理程序，异步运行在中断上下文。中断上下文和特定进程无关。
运行在进程上下文的内核代码是可以被抢占的（Linux2.6支持抢占）。但是一个中断上下文，通常都会始终占有CPU（当然中断可以嵌套，但我们一般不这样做），不可以被打断。正因为如此，运行在中断上下文的代码就要受一些限制，不能做下面的事情：
1、睡眠或者放弃CPU。
      这样做的后果是灾难性的，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉
2、尝试获得信号量
      如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况
3、执行耗时的任务
      中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。
4、访问用户空间的虚拟地址
      因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在终端上下文无法访问用户空间的虚拟地址
````

热部署：代码修改时不需要重启服务，直接刷新页面即可。html页面的修改可以，java 代码不能。 frame deactivation；

### 3、HASH

```text
Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
```

### 4、Spel表达式

模板引擎：

### 5、jar包和war包

```text
jar包和war包都可以看成压缩文件，都可以用解压软件打开，jar包和war包都是为了项目的部署和发布，通常在打包部署的时候，会在里面加上部署的相关信息。这个打包实际上就是把代码和依赖的东西压缩在一起，变成后缀名为.jar和.war的文件，就是我们说的jar包和war包。但是这个“压缩包”可以被编译器直接使用，把war包放在tomcat目录的webapp下，tomcat服务器在启动的时候可以直接使用这个war包。通常tomcat的做法是解压，编译里面的代码，所以当文件很多的时候，tomcat的启动会很慢。
jar包和war包的区别：jar包是java打的包，war包可以理解为javaweb打的包，这样会比较好记。jar包中只是用java来写的项目打包来的，里面只有编译后的class和一些部署文件。而war包里面的东西就全了，包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。
什么时候使用jar包或war包？当你的项目在没有完全完成的时候，不适合使用war文件，因为你的类会由于调试之类的经常改，这样来回删除、创建war文件很不方便，来回修改，来回打包，最好是你的项目已经完成了，不做修改的时候，那就打个war包吧，这个时候一个war文件就相当于一个web应用程序；而jar文件就是把类和一些相关的资源封装到一个包中，便于程序中引用。
```

### 6、web的长连接与短连接

```text
短连接：
在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

长连接：
从HTTP/1.1起，默认使用长连接，用以保持连接特性。
使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive。
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

为什么要有Connection: keep-alive？
在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive，而HTTP/1.1默认是支持长连接的，有没有这个请求头都行。
当然了，协议是这样规定的，至于支不支持还得看服务器（比如tomcat）和客户端（比如浏览器）的具体实现。在实践过程中发现谷歌浏览器使用HTTP/1.1协议时请求头中总会带上Connection: keep-alive，另外通过httpclient使用HTTP/1.0协议去请求tomcat时，即使带上Connection: keep-alive请求头也保持不了长连接。如果HTTP/1.1版本的http请求报文不希望使用长连接，则要在请求头中加上Connection: close，接收到这个请求头的对端服务就会主动关闭连接。
但是http长连接会一直保持吗？肯定是不会的。一般服务端都会设置keep-alive超时时间。超过指定的时间间隔，服务端就会主动关闭连接。同时服务端还会设置一个参数叫最大请求数，比如当最大请求数是300时，只要请求次数超过300次，即使还没到超时时间，服务端也会主动关闭连接。
```

### 7、EL表达式

#id

### 8、路由

路由（routing）是指分组从源到目的地时，决定端到端路径的网络范围的进程   。路由工作在OSI参考模型第三层——网络层的数据包转发设备。路由器通过转发数据包来实现网络互连。虽然路由器可以支持多种协议（如TCP/IP、IPX/SPX、AppleTalk等协议），但是在我国绝大多数路由器运行TCP/IP协议。路由器通常连接两个或多个由IP子网或点到点协议标识的逻辑端口，至少拥有1个物理端口。路由器根据收到数据包中的网络层地址以及路由器内部维护的路由表决定输出端口以及下一跳地址，并且重写链路层数据包头实现转发数据包。路由器通过动态维护路由表来反映当前的网络拓扑，并通过网络上其他路由器交换路由和链路信息来维护路由表。

路由是指路由器从一个接口上收到数据包，根据数据包的目的地址进行定向并转发到另一个接口的过程。路由通常与桥接来对比，在粗心的人看来，它们似乎完成的是同样的事。它们的主要区别在于桥接发生在OSI参考模型的第二层（数据链路层），而路由发生在第三层（网络层）。这一区别使二者在传递信息的过程中使用不同的信息，从而以不同的方式来完成其任务。

### 9、JSON





## 七、javaWeb开发

后端接口开发：参数校验--执行业务逻辑 --插入数据库--返回操作结果

前端（web浏览器）<------发送请求/响应请求-------->  服务器（Tomcat；jboss等等web服务器）

响应的是一些页面，通过解析后浏览器能显示。

>  Tomcat是由Appache组织提供的一种web服务器，提供对jsp和Servlet的支持；它是一种轻量级的web容器（服务器）

### 1、服务器

服务器分为硬件服务器和软件服务器；

硬件服务器就是处理能力，扩展性更好的负责计算，处理存储的计算机。起初这套硬件是没有操作系统的。比如最开始的微型计算机，就是一些芯片的集合。这些芯片本身具有处理计算能力，比如单片机。能够识别机器码，汇编。能够进行简单代码的烧录。

机器码的演化：最初是用黑白纸带，通过纸带控制电路的通断，后来有了磁带，通过磁化来控制电路通断。之后，有了光碟，磁盘。将电路的通断抽象出来，就形成了一连串的0，1数字串。之后再将0和1二进制进行数学操作，就有了8进制，16进制。然后制定了编码表。

以前的电报 ，都是一系列的电磁波通断，传输长短不一样电信号。然后双方按照一定的规则，进行报文的解码，就有了对应的文字。这个解码的规则，是自定义的。这个规则便于学习，方便好记，便被大多数人接受，然后采用这套规则。编码表的演化也遵循这个规律。人们想要把数字和字母跟0和1对应起来，所以就有了ASCii码表。

码表形成之后，负责设计生产计算机的厂商就统一标准。内部解析都按照这个对照表解析。

之后，应用程序就从纸带--磁带--0和1组合的机器码--汇编语言。

计算机的产生，最初就是为了进行加减乘除的数学运算；这个是模拟电路和数字电路技术的发展演化来的。由于不管多复杂的计算，都能够进行细分，最终变为加减法，而加减法对应的是电路的逻辑运算。所以电路得到了应用。由于汇编语言是跟硬件强相关的。需要知道芯片的物理接口怎么接。才能判断是置为0还是置为1。所以难以被大多数人学习掌握。这就演化出来了B语言。

在B语言之前，由于单个芯片的计算能力有限。所以就有了不同的芯片。它们专门负责不同的事情，比如计算，存储，缓存，显示等等。这些芯片可以进行组合。而最终组合了一套硬件系统，它满足了大多数的任务需求。这个硬件系统之后又被一个应用软件给统一管理起来。这就是最初的unix操作系统。此时，已经黑白有了显示器。输入盘。B语言是一种无数据类型的语言，所有的数据也和机器码相对应。并且程序员可以直接通过内存地址操作内存。之后，B语言进行改进，引入了数据类型的概念。最终B语言就演化成了C语言。

C语言进行演化，产生了函数，指针的一些列概念，最后形成了一系列功能强大的函数，函数在操作系统之上组合，相互调用，就形成了应用程序。最开始的操作系统，是没有图形化界面的。都是dos界面。负责的是内存管理，存储管理等硬件资源的管理。

Linux就是目前管理硬件资源的操作系统。windows和苹果的操作系统都是在linux上演化而来，进行了图形界面和其他一些功能拓展。安装了**linux操作系统**的计算机，还不能算真正的软件服务器**。Linux内核主要负责系统的进程管理、内存管理、文件系统、网络功能、硬件驱动**；它还没有服务器的功能。软件服务器是要能够处理客户端请求并且能返回处理结果的软件。通常所说的服务器开发，是在Linux操作系统上进行软件开发。而Linux操作系统的界面是dos界面。它提供了一系列的指令，比如文件的新建、存储命令等等。不同于图形化界面的鼠标点击（实际上只是封装了命令），操作Linux界面需要自己输入命令符号。

```text
Linux主要负责系统的进程管理、内存管理、文件系统、网络功能、
1、进程管理：
内核负责创建和销毁进程, 并处理进程与输入和输出设备的不同进程间的数据处理， 调度器，控制进程如何共享 CPU, 是进程管理的一部分. 更通常地, 内核的进程管理活动实现了多个进程在一个单个或者几个 CPU 之上的抽象.
2、内存管理：
计算机的内存是主要的资源, 处理它所用的策略对系统性能是至关重要的. 内核为所有进程的每一个都在有限的可用资源上建立了一个虚拟地址空间. 内核的不同部分与内存管理子系统通过一套函数调用交互, 从简单的 malloc/free 对到更多更复杂的功能.
3、文件系统、
Unix 在很大程度上基于文件系统的概念; 几乎 Unix 中的任何东西都可看作一个文件. 内核在非结构化的硬件之上建立了一个结构化的文件系统, 结果是文件的抽象非常多地在整个系统中应用. 另外, Linux 支持多个文件系统类型, 就是说, 物理介质上不同的数据组织方式. 例如, 磁盘可被格式化成标准 Linux 的 ext3 文件系统, 普遍使用的 FAT 文件系统, 或者其他几个文件系统.
4、网络功能、
网络必须由操作系统来管理, 因为大部分网络操作不是特定于某一个进程: 进入系统的报文是异步事件. 报文在某一个进程接手之前必须被收集, 识别, 分发. 系统负责在程序和网络接口之间递送数据报文, 它必须根据程序的网络活动来控制程序的执行. 另外, 所有的路由和地址解析问题都在内核中实现.
5、硬件驱动、
几乎每个系统操作最终都映射到一个物理设备上. 除了处理器, 内存和非常少的别的实体之外, 全部中的任何设备控制操作都由特定于要寻址的设备相关的代码来进行. 这些代码称为设备驱动. 内核中必须嵌入系统中出现的每个外设的驱动, 从硬盘驱动到键盘和磁带驱动器. 内核功能的这个方面是本书中的我们主要感兴趣的地方.
```

### 2、Servlet架构

Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。

使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。

![image-20201110180023246](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\image-20201110180023246.png)

Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。

### 3、Tomcat架构

**先抛开对 Tomcat 的认识，想一下，如果没有 Tomcat，我们想访问到我们的工程需要干些什么？**

想要在浏览器访问工程，需要 URL，那么就是要有 IP 和端口，（我们这里拿本机说话，所以采用 localhost），换句话说，在本机上，我们需要一个提供服务的端口；

这个服务要能够识别我在工程中web.xml 中配置的访问路径，并且对应到我自己的servlet 处理器，然后做我的业务逻辑；

我的业务逻辑做完后，要把结果通知给 Client；

Tomcat 本身是一个 servlet 容器，进行servlet 管理， HttpServletRequest，HttpServletResponse。

![image-20201110181706230](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\image-20201110181706230.png)

> 1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化;
> 2、Container用于封装和管理Servlet，以及具体处理Request请求；

![img](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\servlet连接)

多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制

#### 1、server.xml文件

```xml
<Server port="8005" shutdown="SHUTDOWN">
  <Listener className="org.apache.catalina.startup.VersionLoggerListener" />
  <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
  <Listener className="org.apache.catalina.core.JasperListener" />
  <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
  <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
  <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" />
  <GlobalNamingResources>
    <Resource name="UserDatabase" auth="Container"
              type="org.apache.catalina.UserDatabase"
              description="User database that can be updated and saved"
              factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
              pathname="conf/tomcat-users.xml" />
  </GlobalNamingResources>
  <Service name="Catalina">
    <Connector port="8080" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" />
    <Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
    <Engine name="Catalina" defaultHost="localhost">
      <Realm className="org.apache.catalina.realm.LockOutRealm">
        <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
               resourceName="UserDatabase"/>
      </Realm>
      <Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">
        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="localhost_access_log." suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
      </Host>
    </Engine>
  </Service>
</Server>

```

流程图

![img](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\tomcat内部逻辑)





#### 2、Tomcat小结

Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；
Server掌管着整个Tomcat的生死大权；
Service 是对外提供服务的；
Connector用于接受请求并将请求封装成Request和Response来具体处理；
Container用于封装和管理Servlet，以及具体处理request请求；

一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！

Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！

#### 3、Connector架构分析

Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。

因此，我们可以把Connector分为四个方面进行理解：

（1）Connector如何接受请求的？
（2）如何将请求封装成Request和Response的？
（3）封装完之后的Request和Response如何交给Container进行处理的？
（4）Container处理完之后如何交给Connector并返回给客户端的？

首先看一下Connector的结构图（图B），如下所示：

![img](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\70)

Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。

其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。

（1）Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。

（2）Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。

（3）Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。

至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？

#### 4、Container架构分析

Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下（图C）：

![img](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\71)

4个子容器的作用分别是：

（1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；
（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；
（3）Context：代表一个应用程序，对应着平时开发的**一套程序**，或者一个WEB-INF目录以及下面的web.xml文件；
（4）Wrapper：每一Wrapper封装着一个Servlet（小服务程序）；狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。

![image-20201111101805699](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\4)

下面找一个Tomcat的文件目录对照一下，如下图所示：

![img](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\1)

Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。

我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用[http://www.ledouit.com/docs](https://link.zhihu.com/?target=http%3A//www.ledouit.com/docs)进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。

看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！

#### 5、Container如何处理请求

Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）

Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。

![img](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\2)

但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：

（1）每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；

（2）在上层容器的管道的BaseValve中会调用下层容器的管道。

我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。

Pipeline的处理流程图如下（图D）：

![img](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\3)

（1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；

（2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。

（3）当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！

（4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。

### 4、Tomcat使用

Servlet程序从2.5版本是目前使用最多的(xml)，从Servlet3.0开始使用注解版本的servlet。

Tomcat目录结构：

bin：专门用来存放Tomcat服务器的可执行文件

conf: 专门用来存放Tomcat服务器的配置文件

lib: 专门用来存放Tomcat服务器的jar包。

logs: 存放Tomcat服务器运行时输出的日志信息

temp:存放服务器运行时产生的临时数据

webapps:存放部署的web工程

work:tomcat工作时的目录，用来存放运行时jsp翻译为Servlet的源码和session序列化的目录。

#### 1、如何部署web项目到tomcat

1、只需要把工程的目录拷贝到webapps目录下，该目录下一个目录就是一个工程。

localhost:8080/book/index.html

2、修改配置文件

找到Tomcat下的conf目录下 Catalina\localhost\,新建一个项目的webxlm文件。

```xml
<Context path="/web/03"  访问路径    docBase="E:\IdeaProjects\JavaWeb\out\artifacts\web03_war_exploded" />  工程文件的目录（位置)
```

手动拖动html文件到浏览器，浏览器是file协议。告诉浏览器直接读取协议后面的路径，解析展示在浏览器上即可

如果是在浏览器地址栏输入的是http://,浏览器使用的协议是http协议。原理不同。

> 浏览器          协议+ip地址+端口号+工程路径+.html文件。 http://localhost:8080/book/index.html
>
> 服务器Tomcat       服务器收到请求后读取访问的资源文件，然后将响应结果回传给浏览器，浏览器解析成页面。

Tomcat默认访问的是ROOT工程的index.html(index.jsp)；

web工程的目录结构：规定必须有WEB-INFO,下面必须有 lib,classes,web.xml文件

web.xml文件是整个web工程的配置部署描述文件，可以在这里配置很多web工程的组件。比如：Servlet程序；Fileter过滤器，Listener监听器，session超时等等。Tomcat首先加载自己的web.xml文件，然后来加载这个文件。

classes文件存放整个项目编译的字节码文件。lib目录存放依赖的jar包。把web-info发布就好了。不用给源代码。

#### 2、idea社区版maven工程部署web项目

需要把项目添加到tomcat服务器，run---edit configuration --maven --create configutation

![image-20201111164247938](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\5)

#### 3、Servlet技术

Servlet是JavaEE的规范之一，规范就是接口

![image-20201112094101524](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\7)

**Servlet是Javaweb三大组件之一，三大组件：Servlet程序，Filter过滤器，Listener监听器**

用来接收客户端client的请求，并响应数据给client;

实现Servlet程序的步骤：编写一个类，去实现servlet接口----实现servlet的service方法，处理请求，并响应数据----到web.xml中去配置servlet程序的访问地址

在SpringBoot中，需要先实现三大组件的实现方法，然后用注解@Bean把三大组件给添加到容器中。

Spring注解驱动开发：spring框架认为，所有的组件都应该添加到IOC容器中，组件之间的关系通过容器进行自动装配。而不需要自己去 new一个组件对象。（类和类的实例, 组件和组件的实例化对象, 实例化之后，内存中才有这个对象，才有类的相关功能。特殊情况：**静态类。静态类在加载的时候，就在内存中给这些static修饰的 字段属性，方法分配了内存空间。）**

```java
//Person 类不是静态类
class Program{
    static void main(String[] args){
        Person p = new Persong();
        p.test();//如果不先实例化Person,就无法调用Person类中的test方法。
        Person.play();//play方法被static修饰.
    }
}

而静态方法的调用：类名.方法名；
```

在Spring框架中，IOC是通过反射来实现的。

````xml
javaWeb项目web.xml文件 servlet的配置
<!--可以配置多个srvlet-->
1 <servlet>
    <!--一个Servlet程序的别名-->
2     <servlet-name>servlet1</servlet-name>
    <!--servlet程序的全类名-->
3     <servlet-class>net.test.TestServlet</servlet-class>
4 </servlet>
5  <!--给servlet程序配置访问地址-->
6 <servlet-mapping>
    <!--告诉服务器，我当前配的地址是给哪个servlet程序使用-->
7     <servlet-name>servlet1</servlet-name>
    <!--  url-pattern的意思是所有的.do文件都会经过TestServlet处理。
		/hello : http://ip.port/工程路径/hello
-->
8     <url-pattern>*.do</url-pattern>
9 </servlet-mapping>
````

##### 1、 **Servlet的生命周期**

```xml
构造 servlet，                                                                             使用 init 方法将其初始化。 
<!--前两步是在第一次访问创建Servlet程序会调用-->
处理来自客户端的对 service 方法的所有调用。 
<!--web工程停止的时候调用-->
从服务中取出 servlet，然后使用 destroy 方法销毁它，最后进行垃圾回收并终止它。 
```

##### 2、 **Servlet的请求分发处理**

```java
HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;
String method = httpServletRequest.getMethod();
if("GET".equal(method)){
    doGet();
}else if("POST".equal(method)){
    doPost();
}
void doGet(){};
void doPost(){};
```

一般在实际业务开发中，很少implements Servlet接口，通过编写一个类 extends HttpServlet类来进行开发；

##### 3、**servletConfig**

 可以用来获取servlet程序的别名name，init-param,servlet-context;

```java
<!--servlet规范-->
public interface Servlet {
    void init(ServletConfig var1) throws ServletException;
    ServletConfig getServletConfig();
   
    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;
    
    String getServletInfo();
    void destroy();
}
public interface ServletConfig {
    String getServletName();
    ServletContext getServletContext();
    String getInitParameter(String var1);
    Enumeration<String> getInitParameterNames();
}
public abstract class GenericServlet implements Servlet, ServletConfig, Serializable {
    private static final String LSTRING_FILE = "javax.servlet.LocalStrings";
    private static ResourceBundle lStrings = ResourceBundle.getBundle("javax.servlet.LocalStrings");
    
    private transient ServletConfig config;
     public void init(ServletConfig config) throws ServletException {
        this.config = config;
       	this.init();
//将传入的config对象赋值给成员变量config,this总是指向当前调用该变量或者方法的对象。
//this, 一个官方的说法是，this首先是一个对象,它代表调用这个方法的对象。
//根据面向对象的基本语法,每当调用变量或者函数（方法）的时候,都要按照类名.变量(函数)的格式来调用,意即每个变量或函数都必须属于某一个实际的对象而不是一个类(static的除外).
    }
	。。。。
}
public ServletConfig getServletConfig(){
    return this.config;
}

ServletConfig servletConfig = getServletConfig();
servletConfig.getInitParameter("paramName");
```

**servlet程序的对象和servletConfig对象都是由Tomcat负责创建；servlet程序默认第一次访问创建。servletConfig对象是每个servlet程序创建就跟着创建。只要在web.xml配置servlet程序时有init-param相关初始化配置，那么就能通过servletConfig对象来获取。**

##### 4、servletContext

ServletContext是一个接口。它表示上下文对象；一个web工程里只有一个ServletContext对象实例；servlet对象是一个域对象；

![image-20201112204734712](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\8)

![image-20201112204847889](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\9)

**接口类型的引用变量**：其实只要有类去实现了接口，那么这个接口就可以实例化；只是它的实例化是通过实现该接口的类来进行赋值的

```java
ServletContext(这是一个接口) context = getServletConfig().getServletContext();(这是实现类中的方法）
```

##### 5、HttpServletRequest类

每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的Http协议信息解析好封装到Request对象中。然后传递到service中的doGet或doPost方法给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的信息。

接口与接口之间，是继承关系，用于不改变原有接口功能同时扩展接口的功能。

```java
public interface HttpServletRequest extends ServletRequest {}
ServletRequest也是一个接口。底层封装了request请求信息。
```

获取页面的请求参数

```xml
<!DOCTYPE html>
<html lang="zh_CN">
<head>
	<meta charset="UTF-8"/>
    <title>Title</title>
</head>
<body>
    <form action="http://localhost:8080/07_servlet/parameterServlet" method="GET">
        用户名：<input type="text" name="username"/><br/>
        <input type="submit"/>
        <!--访问html页面，让后页面点击提交按钮后，服务器就 运行访问到parameterServlet程序-->
        <!--页面的请求参数也一并封装到了HttpServletRequest中-->
    </form>
</body>
</html>
这里的parameterServlet是在web.xml文件中配置的。xml本身的位置在web目录下。
在浏览器的地址栏输入的是： http://localhost:8080/07_servlet/form.html
public class ParameterServlet extends HttpServlet{
	req.setCharacterEncoding("UTF-8");//设置请求体的字符集，从而解决post请求的中文乱码问题,需要在获取请求参数之前调用。
	@Override
	protected void doGet(HttpServletRequest req,HttpServletResponse resp)throws ServletException,IOException{
	String username = req.getParameter("username")
}
}
某个参数有多个值，getParameterValue();获取到的是一个数组；在控制台打印数组是不能直接打印的，需要转换：
Arrays.adList(数组名)；转为list集合。
```

##### 6、请求转发

请求转发是指 服务器收到请求后，从一个资源跳转到另一个资源的操作。

![image-20201113095739889](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\10)

```java
RequestDispatcher requestDispatcher = req.getRequestDispatcher("/servlet2")
requestDispatcher.forward(req,resp);
```

浏览器地址栏没有改变；他们是一次请求；他们共享request域中的数据；可以访问到WEB-INFO(浏览器本身不可以直接访问）请求转发是不能出栈，只能在自己的工程中跳转;

```html

index.html页面有一个超链接，点击之后就跳转；
<a href="a/b/c.html">a/b/c.html</a>
c.html页面也有一个超链接：跳回首页，点击之后回到首页；..的作用是表示目录层级；一个..表示上上级走一层目录
<a href="../../index.html">跳回首页</a>
index.html在web/a/b/c.html
```

所有相对路径在工作时都会参照浏览器当前地址栏的地址。base标签可以设置**当前页面**中所有相对路径工作时参照的路径。

web中，/表示绝对路径

/如果被浏览器解析，得到的地址是：http://ip:port/

```xml
<a href="/">斜杠</a>
```



/如果被服务器解析，得到的地址是：http://ip:port/工程路径

```xml
<url-pattern>/servlet1</url-pattern>得到的地址就是http://localhost:8080/07_servlet/servlet1
servletContext.getRealPath("/");
request.getRequestDispatcher("/");
```

特殊情况：response.sendRedict("/")------把/发送给浏览器解析得到： http://ip:port/

##### 7、HttpServletResponse

跟request一样，每次请求进来，tomcat都会创建一个response对象传递给servlet程序去使用。所谓创建对象就是在内存开辟一个空间，用来存储信息。java 通过构造器来创建对象。调用构造器用new关键字。new的功能解析是jvm来实(?)。HttpServletResponse封装了所有的响应信息。如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象来进行设置

输出流：  字节流   getOutputStream(); 常用于下载    字符流：getWriter();常用于回传字符串

```java
<!--往客户端回传字符串数据-->
    PrintWriter writer = resp.getWriter();
	writer.write("dfs");
resp.setCharacterEncoding("UTF-8");//设置服务器
resp.setHeader("Content-Type","text/html;charset-UTF-8")//设置浏览器
resp.setContentType("text/html;charset-UTF-8")//同时这是服务器和浏览器响应头，需要在获取流对象之前调用才有效。
```

##### 8、请求重定向

![image-20201113111348198](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\11)

```java
Servlet1:
resp.setStatus(302);
resp.setHeader("Location","http://localhost:8080/07_servlet/response2");

resp.setRedict("");
```

浏览器地址栏改变；两次请求；不共享request域中的数据；仍然不能访问WEB-INFO；能访问工程以为的资源；

**BaseDAO**

```java
crud操作总共就两个方法
update(){} insert/update/delete
select(){} 查询，分页查询，各种查询//query
public int update(String sql,Object ... args){
        Connection connection = JdbcUtils.getConnection();
        try{
            return queryRunner.update(connection,sql,args);
        }catch (Exception e){
            e.printStackTrace();
        }finally{
         JdbcUtils.close(connection);
     }
        return -1;
}
//查询返回一个javabean对象
public <T>T queryForOne(Class<T> type, String sql,Object ... args){
    Connection connection = JdbcUtils.getConnection();
     try{
           queryRunner.query(connection,sql,args);
        }catch (Exception e){
            e.printStackTrace();
        }finally{
         JdbcUtils.close(connection);
     }
        return null;
}
//查询返回多个javabean对象
public <T>List<T> queryForList(Class<T> type, String sql,Object ... args){
    Connection connection = JdbcUtils.getConnection();
     try{
           queryRunner.query(connection,sql,new BeanListHandler<T>(type),args);
        }catch (Exception e){
            e.printStackTrace();
        }finally{
         JdbcUtils.close(connection);
     }
        return null;
}
//查询返回一行一列的sql语句
public Object queryForSingleValue(String sql,Object ... args){
    Connection conn = JdbcUtils.getConnection();
    try{
        return queryRunner.query(conn,sql,new ScalarHandler(),args)
    }catch(Execption e){
        e.printStackTrace();
    }finally{
         JdbcUtils.close(connection);
     }
    return null;
}
```

```java
public class UserDaoImpl extends BaseDao(abstra类) implements UserDao{}
```

#### 4、JavaEE项目的三层架构

1、先创建书城所需的数据库和项目的包结构

2、编写数据库表对应的javaBean

3、编写工具类JdbcUtils等；

```text
传统的JDBC：
加载注册驱动，获取连接,执行预编译SQL语句，执行SQL操作，释放数据库连接资源close.

数据库连接池：数据库连接的时候，频繁的连接断开数据库会导致数据库崩溃。
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。
数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数制约。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。
连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。最大连接数由数据库性能决定。

连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。
```

```java
//加载注册驱动
Class.forName("com.mysql.jdbc.Driver");
//URL用于标识数据库的位置，程序员通过URL地址告诉JDBC程序连接哪个数据库，URL的写法为：
//jdbc:mysql:［］//localhost:3306/shen ?参数名：参数值
//Oracle：jdbc:oracle:thin:@localhost:1521:shen
//SqlServer：jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=shen
//MySql：jdbc:mysql://localhost:3306/shen

String url = "jdbc:mysql://localhost:3306/shen";
String username = "shen";
String password = "Anxin062039";
Connection conn = null;			
//2.获取与数据库的链接
conn = DriverManager.getConnection(url, username, password);
//3.获取用于向数据库发送sql语句的statement
Statement st = conn.createStatement();
//4.向数据库发sql
String sql = "select id,name,password,email,birthday from users";
st.executeQuery(sql);//存在SQL注入问题，拼接SQL导致查询条件失效
//3-4步改为
PreperedStatement st =  conn.preparedStatement(SQL)
//Jdbc程序中的ResultSet用于代表Sql语句的执行结果。Resultset封装执行结果时，采用的类似于表格的方式，ResultSet 对象维护了一个指向表格数据行的游标，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进行调用方法获取该行的数据。
 
```

```java
封装的close方法；为了保证断开，放在finally{}模块中
//6.关闭链接，释放资源
	if(rs!=null){
		try{
			rs.close();
		}catch (Exception e) {
			e.printStackTrace();
		}
		rs = null;
	
	}
	if(st!=null){
		try{
			st.close();
		}catch (Exception e) {
			e.printStackTrace();
		}		
	}	
	if(conn!=null){
		try{
			conn.close();
		}catch (Exception e) {
			e.pintStackTrace();
		}
}
```

```java
//使用jdbc对数据库增删改查
public class Demo {
 
	@Test
	public void insert(){
		Connection conn = null;
		Statement st = null;
		ResultSet rs = null;
		try{
			conn = JdbcUtils.getConnection();
			st = conn.createStatement();
			String sql = "insert into users(id,name,password,email,birthday) values(4,'xxx','123','xx@sina.com',to_date('1980-09-09','YYYY-MM-DD'))";
			int num = st.executeUpdate(sql);  //update
			if(num>0){
				System.out.println("插入成功！！");
			}
			
		}catch (Exception e) {
			e.printStackTrace();
		}finally{
			JdbcUtils.release(conn, st, rs);
		}

```

```java
public class JdbcUtils {
	private static String driver = null;
	private static String url = null;
	private static String username = null;
	private static String password = null;
	static{
		try{
			InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream("db.properties");
			Properties prop = new Properties();
			prop.load(in);
			driver = prop.getProperty("driver");
			url = prop.getProperty("url");
			username = prop.getProperty("username");
			password = prop.getProperty("password");
			Class.forName(driver);
		}catch (Exception e) {
			throw new ExceptionInInitializerError(e);
		}
	}
	
	public static Connection getConnection() throws SQLException{
		return DriverManager.getConnection(url, username,password);
	}
	public static void release(Connection conn,Statement st,ResultSet rs){
		if(rs!=null){
			try{
				rs.close();
			}catch (Exception e) {
				e.printStackTrace();
			}
			rs = null;
		}
		if(st!=null){
			try{
				st.close();
			}catch (Exception e) {
				e.printStackTrace();
			}
		}
		if(conn!=null){
			try{
				conn.close();
			}catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
}
```

# Idea调试：

![image-20201113152916380](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\12)

**方法调用栈**

![image-20201113153258779](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\13)

可以查看当前线程有哪些方法调用信息

下面的一行方法调用上面的方法。

#### 5、Controller层

```java 
@RestController
public class EmployeeController{
    @Autowired
    EmployeeService employeeService;
    @GetMapping("/emp/{id}")//区别@GetMapping("/emp/getEmployee"),这个还要拼接？id=..
    Public Employee getEmployee(@PathVariable("id")Integer id){
        Employee employee = employeeService.getEmp(id);
        return employee;//这时会以json形式返回给前端。因为是@Rest  @ResponsBody
    }
    
    @GetMapper("/emp")//如果在浏览器访问输入/emp?id=XXX&name=XXX,会自动封装为employee对象
    Public Employee update(Employee employee){
        Employee emp = employeeService.update(employee);
        return emp;
    }
    @GetMapper("/delemp")//此时在浏览器访问输入的是/emp?id=XXX
    Public Employee delete(Integer id){
        employeeService.delete(id);
        return "success";
    }
}
	
```



## 八、JSP

Jsp全称是Java server page,java的服务器页面；jsp的主要作用是代替servlet程序回传html页面的数据。

因为Servlet程序回传**html页面数据**是一件非常繁琐的事情，开发和维护成本较高。

**JSP**（全称**J**ava**S**erver **P**ages）是由[Sun Microsystems](https://baike.baidu.com/item/Sun Microsystems)公司主导创建的一种**动态网页技术标准**。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成[HTML](https://baike.baidu.com/item/HTML)、[XML](https://baike.baidu.com/item/XML)或其他格式文档的[Web](https://baike.baidu.com/item/Web)网页，然后返回给请求者。JSP技术以[Java](https://baike.baidu.com/item/Java)语言作为[脚本语言](https://baike.baidu.com/item/脚本语言)，为用户的[HTTP](https://baike.baidu.com/item/HTTP)请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。

JSP本质：当第一次访问jsp页面的时候，Tomcat会把jsp页面翻译成为一个java源文件,并且对它进行编译成.class文件。java源文件间接继承了HttpServlet

```java
public abstract class HttpJspBase extends HttpServlet implements HttpJspPage{}
```

jsp翻译的源代码位置：tomcat服务器临时编译位置：c:\Users\Administrator\.IntelliJIdea2019.2\system\tomcat\Tomcat_8_0_5_JavaWeb_8"

## 九、EL表达式

EL：表达式语言；主要是代替JSP页面中的表达式脚本在jsp页面中进行数据的输出

```html
<%@ page contentType="text/heml;charset=UTF-8" language="java" %>
<html>
<head>
	<ttle>Title</ttle>    
</head>
<body>
  	<%
       request.setAttribute("key","值");//这里有分号，联想编译后的java文件,代码脚本
    %>
    表达式脚本输出的key的值是：<%=request.getAttribute("key")==null?"":request.getAttribute("key")%><br/>
    EL表达式输出的key的值是：${key}
    <%
        request.setAttribute("key","request");
        session.setAttribute("key","session");
        application.setAttribute("key","application");
        pageContext.setAttribute("key","pageContext");
     %>
     ${key}
<!--EL表达式主要就是输出域对象的数据；key的值是按照域对象中的从小到大顺序来获取的-->        
</body>
</html>
<!--EL表达式key没有值时输出的是空白，不是null字符 -->
```

session中的数据一旦设置，除非浏览器关闭，否则session的数据会一直在。

```text
数组与集合：
数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值
集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象
数组长度是固定的,不能自动增长
集合的长度的是可变的,可以根据元素的增加而增长
<%
	Person person = new Person();
	person.setName("");
	person.setPhones(new String[]{"","",""})
	List<String> cities=new ArrayList<String>();
	cities.add("北京");
	cities.add("上海");
	cities.add("重庆");
	person.setCities(cities);
	Map<String,Objcet> map = new HashMap<>();
	map.put("key1","value1");
	map.put("key2","value2");
	person.setMap(map);
	pageContext.setAttribute("p",person);
%>
	${p}
```

## 十、JSTL

JSTL标签库 JSP标准标签库；为了替换代码脚本。jsp三大脚本：声明式脚本<%!  %>（基本不用） ;表达式脚本<%=代码 %>被EL替代。

JSTL由五个不同功能的标签库组成

| 功能范围         | URL                                    | 前缀 |
| ---------------- | -------------------------------------- | ---- |
| 核心标签库       | http://java.sun.com/jsp/jstl/core      | c    |
| 格式化           | http://java.sun.com/jsp/jstl/fmt       | fmt  |
| 函数             | http://java.sun.com/jsp/jstl/functions | fn   |
| 数据库（不使用） | http://java.sun.com/jsp/jstl/sql       | sql  |
| XML(不用)        | http://java.sun.com/jsp/jstl/xml       | x    |

使用JSTL标签库:

1.导入JSTL的jar包

2.引入标签库

```xml
<%@ taglib prefix="c" rui="http://java.sun.com/jsp/jstl/core"%>
```

3.使用

```html
<c:set/>
```

## 十一、Filter过滤器

过滤器是JavaWeb的三大组件之一。三大组件分别是：Servlet程序、Listener监听器、Filter过滤器

是JavaEE的规范，也就是接口

作用是拦截请求，过滤响应

常见应用场景：

​	1、权限检查 2、日记操作 3、事务管理

```java
@Override
public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilteChain filterChain){
    HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
    
}
HttpServletRequest http
```

## 十二、VSCODE前端

常用插件：chiness;material theme(主题风格插件);

Prettier(格式化美化代码),下载后点击设置，设置为保存触发。

Bracket Pair Colorizer2：主要作用是将配对的括号显示相同的颜色，不配对的括号显示不同的颜色

Auto Rename Tag:标签重命名，修改标签前部分的时候，后半部分会自动跟着发生变化

Liver Server主要作用是在本地开启一个HTTP Server,并且可以监听ctrl+S动作进行页面自动刷新

Live Sass Compiler 监听并实时编译scss文件，输出css文件

leetcode(需要登陆)算法

CodeRunner:

Vetur:语法高亮，智能感知。

ESLint:语法提示器



vscode启动vue项目：

### 1、vue项目的结构：

![](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\14)



```text
一般一个初步的Vue项目创建好之后都会有这三个文件：index.html 、main.js 、App.js;
1、index.html :众做周知，Vue是单页面形式开发，而这个index.html文件在其中起着特别重要的作用。所有组件（后缀名为.vue都被视为组件）都会通过此文件进行渲染加载。
这个文件，你可以不用管。一般情况下，很少会在这里面进行大量的代码二次编写。
2、main.js : 这个文件，在我看来，它相当于一个C/Java中的入口函数。控制着初次启动Vue项目要加载的组件。
下面是main.js的代码截图，我会对每行代码进行逐一分析
```

### 2、路由

```text
路由——url的分层解析。
第一层  解析到服务器目标机器。这个通常是域名或ip。
第二层  解析到服务器的特定资源文件。这个通常是pathinfo。
第三层  解析特定资源的特定状态。包含在pathinfo参数中。
主要是服务器，资源文件，特定状态定位。

路由的作用就是解析URL，调用对应的控制器（的方法，并传递参数）。客户端的请求是以URL的形式传递给服务器的。传统WEB开发中，URL对应服务器上某个目录下的某个文件。MVC开发则改变了这种对应关系，WEB 服务器会截获所有请求，不做资源存在性检查，直接转发给网站的路由程序。路由器再调用相关的控制器。控制器调用相关的服务，并返回视图对象。路由器再从视图对象中提取生成好的网页代码返回给Web服务器，最终返回给客户端。
```



## 十三、SpringBoot与web开发

spring boot核心是自动配置原理。

````java 
几个核心的注解：
    xxxAutoConfiguration:自动配置类
    @EnableConfigurationProperties(WebMvcProperties.class)
    @ConfigurationProperties(prefix="spring.datasource")
实例：getBootStrap.com
    @ResponseBody//给前端返回json字符串
    @RequsetMapping("/hello")
    @ConditionalOnMissingBean;
//判断是否有这个类，没有才返回一个new 对象;
    @Bean
    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter(){
        return new OrderedHiddenHttpMethodFilter();
    }
````

springboot选中需要的模块，默认就将这些场景配置好了，只需要在配置文件中指定少量的配置就可以运行起来。

### 1、SpringBoot对静态资源映射规则---WebJars

在springweb项目结构中，有WEB-INF目录；而springBoot项目结构中没有该目录。

**所有spring相关的配置：WebMvcAutoConfiguration.java**

SpringBoot对静态资源映射规则：

```java 
@ConfigurationProperties(prefix="spring.resources",ignoreUnknownFields=flase)
public class ResourceProperties implements ResourceLoaderAware{}
```

springBoot 以jar包的方式运行， 嵌入式的tomcat,所以是不支持JSP。

### 2、Filter、Listener、Servlet三大组件

```java
@Override
public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChain filterChain){
    HttpServletRequest httpServletRequest=(HttpServletRequest)servletRequest;
    HttpSession session = httpServletRequest.getSession();
    Object user = session.getAttribute("user");
    if(user == null){
       		 servletRequest.getRequestDispatcher("/login.jsp").forward(servletRequest,servletResponse);
        return;  
    }else{
        filterChain.doFilter(servletRequest,servletResponse)
    }
    
}
```

Filter的使用步骤：1、编写一个类去实现Filter接口；

​								2、实现过滤方法doFilter();

​								3、web.xml中去配置Filter的拦截路径。

```text
Filter的生命周期：
1、构造器方法；2、init()初始化方法------在web工程项目启动的时候就创建完成
3、doFilter()----web项目运行时执行
4、destroy()销毁----停止web工程的时候，Filter也就销毁
```

### 3、Listener

监听器的作用是监听一些事件的发生从而进行一些操作，比如监听ServletContext,HttpSession的创建，销毁，从而执行一些初始化加载配置文件的操作，

当Web容器启动后，Spring的监听器会启动监听，监听是否创建ServletContext的对象，如果发生了创建ServletContext对象这个事件(当web容器启动后一定会生成一个ServletContext对象，所以监听事件一定会发生)，ContextLoaderListener类会实例化并且执行初始化方法，将spring的配置文件中配置的bean注册到Spring容器中，

监听的操作是读取WEB-INF/applicationContext.xml，但是我们可以在web.xml中配置多个需要读取的配置文件，如下方所示，读取完成后所有的配置文件中的bean都会注册到spring容器中。

```xml
<context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>
            /WEB-INF/config/application-context.xml
            /WEB-INF/config/cache-context.xml
            /WEB-INF/config/captcha-context.xml
            /WEB-INF/config/jeecms/jeecore-context.xml
            /WEB-INF/config/jeecms/jeecms-context.xml
            /WEB-INF/config/shiro-context.xml
            /WEB-INF/config/plug/**/*-context.xml
            /WEB-INF/config/quartz-task.xml
            /WEB-INF/config/zxw/zxw-context.xml
        </param-value>
    </context-param>
```

### 4、Mybatis整合

```prope
开启驼峰命名
mybatis.configuration.map-underscore-to-camel-case=true
```

## 十四、JAVA虚拟机 JVM和web服务器

socket又是怎么理解？

## 十五、Spring IOC/DI/AOP

```java
DI注解：
    pulbic class SomeBean{
        void doWork(){
            system.out.println("xxxx");
        }
    }
<bean id="someBean" class="cn.volfcode.springTest.SomeBean"/>
    @Autowired //表示自动按照类型去Spring容器中找到bean对象，并设置给该字段。如果多个类型，按照名字找。
    @Qualifier("cat1")
    private Somebean bean;
使用注解有三个要素：1、注解本身，2、被贴的程序元素，
    3、第三方的程序：DI注解解析器，<context:annotation-config/>
    public class Person{
        @Autowired
        private Cat c1;//前提是将Cat添加到了Spring的容器中。
        //@Autowired
        //public  void setC1(Cat c1){
        //this.c1=c1;
    	//	}
        public String toString(){
            return "Person {c1=" + c1 + "}";
        }
    }
```

### 1、@Autowired注解

Spring的依赖注入：在Spring框架中，定义了组件，比如person类，这个类里面有字段name,age;也提供了相应的属性---getter和setter方法。还有toString()方法用于打印对象。在以前，需要调用这个组件的时候，需要用new关键字。然后通过new的对象来给对象进行设置属性值。p.set(name)。出现Spring框架后，运用反射的原理。将这些属性设置的过程提取到了xml文件中。这样便于了代码维护。xml中的方式是

```xml
<bean id="q" class="组件的全限定名">        //id相当于Person p中的p；
    <property name="" value=""/>
</bean>
```

在Spring应用启动的时候，就会扫描这些xml文件，将组件添加到容器中，并给这些容器中的对象设置相应的属性值。

在类的抽象中，除了具体的物品、人物，还有各种方法，动作行为的抽象。比如很多的工具类。在物体抽象出来的类中，也会有相应的动作方法。当容器中添加了组件，就能通过bean的id来调用它的方法。

而注解的方式进行组件的添加，注入，是类似于语法糖的形式。底层原理也是反射。为了区分不同作用的组件，采用了不同的注解来进行添加。比如@Service,@Controller,@Component,@Repository(用于DAO层)。

**@Autowired给一个类注入另一个类的对象，然后通过对象来调用set和get方法来设置属性值；或者通过对象来调用它的方法。**

```java 
@Controller
public class TestController {
	//成员属性字段使用 @Autowired，无需字段的 set 方法
	@Autowired
	private TypeService typeService;
	//set 方法使用 @Autowired
	private ArticleService articleService;
	@Autowired
	public void setArticleService(ArticleService articleService) {
		this.articleService = articleService;
	}
	//构造方法使用 @Autowired
	private TagService tagService;
	@Autowired
	public TestController(TagService tagService) {
		this.tagService = tagService; 
	}
```

### 2、@Mapper

```java 
@MapperScan("com.springbootcache.mapper")
@SpringBootApplication
@EnableCaching
public class SpringbootCacheApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringbootCacheApplication.class, args);
	}

}
@Mapper
public interface UserMapper {
    @Select("SELECT * FROM tb_user WHERE id=#{id}")
    public User getUserById(Integer id);
}
```

以上等价于

```java
//注意，这里同样需要在启动类添加注解@MapperScan(“com.springbootcache.mapper”)
@Component
public interface UserDao {
    public User getUserById(Integer id);
}
//在resources里面新建mapper文件夹存放mapper.xml映射文件
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.springbootcache.mapper.UserDao " >
	<select id="getUserById" resultType="com.springbootcache.domain.User">
		"SELECT * FROM tb_user WHERE id=#{id}
	</select>
</mapper>
//还有在application.properties配置文件里面
//#映射表
mybatis.mapper-locations=classpath:mapper/*.xml
mybatis.type-aliases-package=com.springbootcache.domain
```



## 十六、SpringBoot高级应用

### 1、SpingBoot与缓存Cache

> **JSR-107    SpringBoot缓存抽象     整合redis**

缓存的位置是在内存中。比如：临时性的数据，比如给用户发送的验证码，三分钟有效，这个验证码一般放在缓存中。热点的数据。

java Catching定义了5个接口。**CachingProvider,CacheManager,Cache,Entry,Expiry**

**CachingProvider**:定义了创建、配置、获取、管理和控制多个**CacheManager**.一个应用可以在运行期间访问多个CachingProvider.

**CacheManager**:定义了创建、配置、获取、管理和控制多个Cache,这些Cache存在于**CacheManager**的上下文中。一个CacheManager仅被一个CacheProvider所拥有。

**Cache**是一个类似于Map的数据结构并临时存储以key为索引的值。一个cache仅被一个CacheManager所拥有

**Entry**是一个存储在Cache中的**key-value**对

**Expiry**每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过**ExpiryPolicy**设置

**断点位置打在行类，不要打在方法上**   debug=true,控制台显示缓存信息。

#### 1、整合redis做缓存

redis中国--redis命令中心。redis客户端右键点击Console；



### 2、SpringBoot与消息

#### 1、基本概念

> JMS、AMQP、RabbitMQ

1、大多数应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力

2、消息服务中两个重要概念：消息代理（message broker）和目的地（destination）当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定的目的地

3、消息队列主要有两种形式的目的地：队列（queue）点对点消息通信（point-to-point) 主题topic：发布(publish)/订阅（subscribe）消息通信 

**异步处理**

![在这里插入图片描述](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\15)

**应用解耦**

![在这里插入图片描述](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\16)

**流量削峰**

![在这里插入图片描述](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\17)

4、点对点式： – 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容， 消息读取后被移出队列 – 消息只有唯一的发送者和接受者，但并不是说只能有一个接收者

5、发布订阅式： – 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么 就会在消息到达时同时收到消息

6、JMS（Java Message Service）JAVA消息服务：
– 基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现

7、AMQP（Advanced Message Queuing Protocol）
– 高级消息队列协议，也是一个消息代理的规范，兼容JMS
– RabbitMQ是AMQP的实现

![在这里插入图片描述](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\18)

8、Spring支持
– spring-jms提供了对JMS的支持
– spring-rabbit提供了对AMQP的支持
– 需要ConnectionFactory的实现来连接消息代理
– 提供JmsTemplate、RabbitTemplate来发送消息
– @JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发 布的消息
– @EnableJms、@EnableRabbit开启支持

9、Spring Boot自动配置
– JmsAutoConfiguration
– RabbitAutoConfiguration

#### 2、RabbitMQ

是一个由erlang开发的AMQP(Advanced Message Queue Protocol)的来源实现

核心概念Message                                                                                                                                                              消息是不具名的，它由消息头和消息体组成，消息体是不透明的，而消息头则由一系列的可选属性组成。这些属性包括routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出该消息可能需要持久性存储)

publisher                                                                                                                                                                            消息的生产者，也是一个向交换器发布消息的客户端应用程序

Exchange（一个组件）                                                                                                                                                     交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有四种类型：direct(默认 点对点） ,fanout,topic和headers（后三个是主题订阅），不同类型的Exchange转发消息的策略有所区别。通过交换器来决定消息发往哪个队列。

Queue                                                                                                                                                                                 消息队列，用来保存消息知道发送给消费者，它是消息的容器。也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走

Binding                                                                                                                                                                                绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键routing-key将交换器和消息队列连接起来的路由规则。所以可以将交换器理解成一个由绑定构成的路由表。Exchange和Queue的绑定可以是多对多的关系。

Connection                                                                                                                                                                          网络连接，比如一个TCP连接

Channel                                                                                                                                                                              信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所 以引入了信道的概念，以复用一条 TCP 连接。

Consumer
消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。

Virtual Host
虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加 密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有 自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定， RabbitMQ 默认的 vhost 是 / 。

Broker
表示消息队列代理服务器实体

![在这里插入图片描述](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\19)

#### 3、RabbitMQ运行机制

AMQP 中的消息路由
• AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 **Exchange 和 Binding** 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被 消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。

![img](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\20)

Exchange 类型
• Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型： direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多， 目前几乎用不到了，所以直接看另外三种类型：

**消息中的路由键**（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队 列名完全匹配，如果一个队列绑定到交换机要求路由键为 “dog”，则只转发 routing key 标记为“dog”的消息，不会转 发“dog.puppy”，也不会转发“dog.guard”等等。它是完全 匹配、单播的模式。

![img](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\21)

每个发到 fanout（展开，分列，转型数目） 类型交换器的消息都会分到所 有绑定的队列上去。fanout 交换器不处理路由键， 只是简单的将队列绑定到交换器上，每个发送 到交换器的消息都会被转发到与该交换器绑定 的所有队列上。很像子网广播，每台子网内的 主机都获得了一份复制的消息。fanout 类型转发 消息是最快的。

广播模式：收到消息后不管路由键是什么，给绑定的每个消息队列发一份消息。

![在这里插入图片描述](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\22)

topic 交换器通过模式匹配分配消息的路由键属 性，将路由键和某个模式进行匹配，此时队列 需要绑定到一个模式上。它将路由键和绑定键 的字符串切分成单词，这些单词之间用点隔开。 它同样也会识别两个通配符：符号“#”和符号 “* ” 。 # 匹配 0 个或多个单词 ， *匹配一个单词。单词级别匹配

对路由键进行模糊匹配，有选择性的发送给消息队列

![在这里插入图片描述](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\23)

#### 4、RabbitMQ整合

```linux
使用工具远程连接linux
docker images//查看以安装镜像
docker pull registry.docker-cn.com/library/rabbitmq:3-management
//运行镜像
docker run -d -p 5672：5672 -p 15672：15672 --name myrabbitmq df0ee1f2343b
//-d(后台运行)
//-p(暴露端口)
//5672:5672(把主机的5672映射到docker容器的5672)客户端和rabbitmq通信端口
//15672：15672 管理界面访问web页面的端口
//--name 别名
//df0ee1f2343b 镜像的id,启动哪个镜像
docker ps//列出容器
```

```text
浏览器访问虚拟机的端口:  比如118.24.44.169：15672  进入到 rabbitmq的管理界面 guest 密码也是guest登陆
durable 持久化，下一次重启交换器依然在

```



1. 引入 spring-boot-starter-amqp
2. application.yml配置
3. 测试RabbitMQ
   1. AmqpAdmin：管理组件
   2. RabbitTemplate：消息发送处理组件

![在这里插入图片描述](C:\Users\yigeziyu\Desktop\soft\网页笔记\软件开发问题记录\24)

**application.properties**

```properties
spring.rabbitmq.host=192.168.169.131
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
```

**RabbitmqApplication**

```java
package com.example.rabbitmq;

import org.springframework.amqp.rabbit.annotation.EnableRabbit;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 自动配置
 *  1、RabbitAutoConfiguration
 *  2、有自动配置了连接工厂ConnectionFactory；
 *  3、RabbitProperties 封装了 RabbitMQ的配置
 *  4、 RabbitTemplate ：给RabbitMQ发送和接受消息；
 *  5、 AmqpAdmin ： RabbitMQ系统管理功能组件;
 *  	AmqpAdmin：创建和删除 Queue，Exchange，Binding
 *  6、@EnableRabbit +  @RabbitListener 监听消息队列的内容
 *
 */
@EnableRabbit  //开启基于注解的RabbitMQ模式
@SpringBootApplication
public class RabbitmqApplication {

    public static void main(String[] args) {
        SpringApplication.run(RabbitmqApplication.class, args);
    }
}
```

```java
@Service 
public class BookService{
    @RabbitListener(queues="被监听的消息队列名字")//只要消息队列有内容进去，下面的方法就会被调用
    public void receive(Book book){
       	System.out.println("收到消息"+book)
    }
    @RabbitListener(queues="被监听的消息队列名字")//只要消息队列有内容进去，下面的方法就会被调用
    public void receive1(Message message){//得到消息头信息
       	System.out.println("收到消息"+message.getBody());
        System.out.println("收到消息"+message.getMessageProperties());
    }
}//需要开启EnableRabbit
```

**RabbitmqApplicationTests**

```java
package com.example.rabbitmq;
import com.example.rabbitmq.bean.Book;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import java.util.HashMap;
import java.util.Map;
@RunWith(SpringRunner.class)
@SpringBootTest
class RabbitmqApplicationTests {
    @Autowired
    RabbitTemplate rabbitTemplate;
    @Autowired
    AmqpAdmin amqpAdmin;
    @Test
    public void createExchange(){
//		amqpAdmin.declareExchange(new DirectExchange("amqpadmin.exchange"));
//		System.out.println("创建完成");
//		amqpAdmin.declareQueue(new Queue("amqpadmin.queue",true));
        //创建绑定规则
//		amqpAdmin.declareBinding(new Binding("amqpadmin.queue", Binding.DestinationType.QUEUE,"amqpadmin.exchange","amqp.haha",null));
        //amqpAdmin.de
    }
    //单播（点对点）
    @Test
    void contextLoads() {
        //Message需要自己构造一个；定义消息体内容和消息头
        //rabbitTemplate.send(exchage,routeKey,message);
        
        //object默认当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq
        //rabbitTemplate.convertAndSend(exchage,routKey,object);
        Map<String,String> map=new HashMap();
        map.put("a","zs");
        map.put("b","ls");
        //对象被默认序列化以后发送出去，默认是java的序列化
        rabbitTemplate.convertAndSend("amq.direct","rabbitmq",new Book("西游记","吴承恩"));
        //定义了一个book对象，提供了有参构造器和无参构造器。
        //rabbitmq中显示{“bookname":"西游记","author":"罗贯中"}
    }
    //接收数据
    //如何将消息以json的形式发送出去，RabbitTemplate中有一个MessageConverter
    //序列化：SerializationUtils,将对象信息转化为二进制，以便于传输，跨平台。
    @Test
    public void receive(){
        Object o = rabbitTemplate.receiveAndConvert("rabbitmq");//消息队列的名称
//        class java.util.HashMap
//        {a=zs, b=ls}
        System.out.println(o.getClass());
        System.out.println(o);//得到的是hashMap,接收后消息队列中就没有数据了
    }
    //广播
    @Test
    public void sendMsg(){
        rabbitTemplate.convertAndSend("amq.fanout","",new Book("mnmn","kjkj"));
    }
}
```

```java
@Configuration
public class MyAMQPConfig{
    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }
}//此时rabbitTemplate会加载这个MessageConverter
```

```java
//运用AmqpAdmin来创建消息对列
@Autowired
AmqpAdmin amqpAdmin;
amqpAdmin.declareQueue();//创建一些组件declare:宣布，声明
```































### 3、SpringBoot与检索

### 4、任务

### 5、安全

### 6、分布式

### 7、监控管理

### 8、部署









## 十七、服务器上自动化部署前后端项目

 

## 十八、服务部署故障监听

# SOCKET

# Nginx

# Nacos

# Redis

# Docker

# Linux

## 1、分区

分区类型：主分区最多只能4个。（一个大衣柜只能最多分四个小衣柜）

扩展分区最多只能1个；主分区加扩展分区只能最多4个；扩展分区不能写入数据，只能包含逻辑分区；（小衣柜中再分两个小格子）

逻辑分区能读取写入数据，格式化。（小格子衣柜）

##  2、格式化

格式化又称逻辑格式化，它是指根据用户选择的文件系统（如windows的FAT16,FAT32,NTFS；Linux的EXT2,EXT3,EXT4（默认），在磁盘的特定区域写入特定的数据，在分区中划分一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。

格式化的目的是写入文件系统，文件系统最小的单元是4k，数据都是存放在这个最小单元里面，每个单元对应有一个i节点号，（iLood）。通过i节点号去找数据，取出这些存储单元中的数据，然后拼凑在一起。

在Linux中，所有的硬件设备都是文件。

## 3、硬盘设备文件名

| 硬件                                            | 设备文件名           |
| ----------------------------------------------- | -------------------- |
| IDE硬盘(古老)                                   | /dev/hd[a-d]         |
| SCSI/SATA/USB硬盘（主要sda硬盘，理论速度500M/S) | /dev/sd[a-p]         |
| 光驱                                            | /dev/cdrom或/dev/sr0 |
| 软盘                                            | /dev/fd[0-1]         |
| 打印机（25针)                                   | /dev/fd[0-2]         |
| 打印机(usb)                                     | /dev/usb/1p[0-15]    |
| 鼠标                                            | /dev/mouse           |

sda1:sd硬盘第一块硬盘1号分区。默认约定：1，2，3，4只留给主分区命名（主分区即使没有4个）；逻辑分区只从5开始；5代表第1个逻辑分区

## 4、挂载

（window中分配盘符）Linux称为挂载，盘符在Linux称为挂载者

必须分区

**/（根分区）**：最高一级

**swap分区:虚拟内存，可以当内存使用。不超过2G.**

建议：/boot(启动分区，200M)专门用来保存启动的数据，不再另外写入数据。

**步骤：**

**分区：把大硬盘分为小的逻辑分区**

**格式化：写入文件系统**

**分区设备文件名：给每个分区定义设备文件名**

**挂载：给每个分区分配挂载点。挂载点必须是目录** 而且目录必须是空目录

## 5、Linux安装

虚拟机：SmarTTY远程连接linux。docker hub中下载镜像，进行docker安装。镜像加速国内站点：docker中国。www.docker-cn.com；包含流行的公有镜像。

```docker
docker pull registry.docker.-cn.com/library/redis（文件版本）
```



# 物联网技术

通信模块--报文的发送，接受，加密，解析

数据模块：数据的清洗，数据中心，数据库的建立

网关：

应用模块：各种web应用开发；前端页面，后端服务，分布式应用，多线程，分发。缓存。

运维部署：服务器部署，自动化部署，

# 大数据处理相关技术

## 1、国网用电采集项目

```text
安徽用采定位调整：原有用采业务持续保持不变，基于共享理念提升用采输出能力，在大数据环境中，通过租户形式，开辟出独立的，可供外部使用的空间，以hive为数据基础，azkaban为计算平台，允许外部系统在独立空间内开展数据统计计算，结果输出等操作。
空间要求：
1）租户权限划分清晰，与用采原有数据完全割裂，不对用采正常稳定运行造成安全隐患。
2）计算服务资源按需分配，并需现团队提供开发规范。部署程序需提交业务说明，同时做好数模维护工作。
1.租户权限划分:使用Apache Ranger
Apache Ranger是Hortonworks公司发布的一个Hadoop安全组件开源组件
优点：
提供了细粒度级（hive列级别）
基于访问策略的权限模型
权限控制插件式，统一方便的策略管理
支持审计日志，可以记录各种操作的审计日志，提供统一的查询接口和界面
丰富的组件支持(HDFS,HBASE,HIVE,YARN,KAFKA,STORM)
支持和kerberos的集成
提供了Rest接口供二次开发
为什么我们选择Ranger
多组件支持(HDFS,HBASE,HIVE,YARN,KAFKA,STORM)，基本覆盖我们现有技术栈的组件
支持审计日志，可以很好的查找到哪个用户在哪台机器上提交的任务明细，方便问题排查反馈
拥有自己的用户体系，可以去除kerberos用户体系，方便和其他系统集成，同时提供各类接口可以调用
2.计算服务资源按需分配
计算资源使用yarn的多租户功能将CPU,内存预先分配。对程序开发透明不需要特殊配置。
3.azkaban没有多租户功能，只能为每个用户都运行一个独立的azkaban服务器来实现权限隔离。或者使用别的任务调度平台如Apache DolphinScheduler。
```



存储技术：

 



# 网站爬虫项目开发



# 常用英文单词

```text
genetate:使形成，发生   generator:发动机；生产者，构造器 cacheEvict:缓存驱逐 evict:赶出，逐出
publisher:出版商，发行人 CONTAINER容器 durab持久化 declare:宣布，声明

```



# 重庆玩耍地点

南川山王坪；



















